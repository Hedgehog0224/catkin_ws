# Управление моторами и движением робота

## 1. Получение, передача и обработка данных

Лидар, дальномер и джойстик передают данные растояния (передаются: ~1000 чисел, 1 число, 3 числа соответственно) в программу **shim_cringe** (главная нода):
- Лидар -> топик scan -> shim_cringe;
- Дальномер -> топик distance -> shim_cringe;
- Джойстик -> топик Mode -> shim_cringe.

После, данные обрабатываются и передаются на моторы через методы класса **Route** (методы **set_speed** и **move**):
- (скорости x, y; режим поворота; функция поворота; поворот Системы Координат) -> set_speed

Внутри **set_speed**:
- (скорости x, y; поворот Системы Координат) -> potateOfSys -> скорости x, y (изначальные значения модифицированны);
- (скорости x, y; режим поворота; функция поворота;) -> _front_potate;
- (режим поворота; функция поворота;) -> __differencial -> производная функции поворота;
- (мотор; скорости x, y; производная функции поворота) -> _single_front_potate (отдельно для каждого мотора).

Из **set_speed** передаётся массив из четырёх чисел, соответствующих скорости каждого из моторов:
- set_speed -> скорости всех моторов.


## 2. Внесение изменений в программу и их влияние на дальнейшее поведение робота
Для отработки навыков программирования моторов робота.

### 2.1 Изменение значений на этапе инициализации
Чтобы связать направление движения робото с направлением движения его колёс существует система координат (Изображение 1). Если подать на каждый мотор одинаковый сигнал, то все моторы будут вращаться в одном направлении (по часовой при взгляде снаружи, против часовой при взгляде от центра). Показателем направления вращения является синяя стрелка. Если сигнал изменить, то вращаться моторы будут в другом направлении.\
Для управления вращением моторов в положительном направлении в заданной системе координат применяются множители для осей **X** и **Y** (x, y).

![Image_1](https://github.com/Hedgehog0224/catkin_ws/blob/docs/Documentation/Images/003-6-1.png)
Изображение 1 - Схема положительного направления движения колёс

Числовые значения множителей для управления движения робота вдоль осей в положительном направлении задаются следующим образом:
- мотор **A** - сонаправлено оси **X** (1, 0);
- мотор **B** - сонаправлено оси **Y** (0, 1);
- мотор **C** - противоположно направленно оси **X** (-1, 0);
- мотор **D** - противоположно направленно оси **Y** (0, -1).

В коде множители для моторов заданы следующим образом (cтрока **35**):
```
# Объекты моторов
    A = Motor( 1,  0)
    B = Motor( 0,  1)
    C = Motor(-1,  0)
    D = Motor( 0, -1)
```

Для эксперимента можно попробовать поменять значения множителей:
**Таблица 1 - Значения множителей**
| №     | Значения множителей   |
|:-----:|-----------------------|
| 1     | A = (0, 0)            |
|       | B = (0, 0)            |
|       | C = (0, 0)            |
|       | D = (0, 0)            |
| 2     | A = (1, 1)            |
|       | B = (1, 1)            |
|       | C = (1, 1)            |
|       | D = (1, 1)            |
| 3     | A = (-1, 0)           |
|       | B = ( 0,-1)           |
|       | C = ( 1, 0)           |
|       | D = ( 0, 1)           |
| 4     | A = (1,0)             |
|       | B = (1,0)             |
|       | C = (0,1)             |
|       | D = (0,1)             |
| 5     | A = (2, 1)            |
|       | B = (2, 1)            |
|       | C = (3,-2)            |
|       | D = (3,-2)            |

Также, можно изменить порядок моторов (строка **41**):
```
# Объект совокупности моторов
    abcd = Route(A, B, C, D)
```

### 2.2 Изменение поведения робота
JoyArr - массив из четырёх элементов, являющимся скоростями моторов (порядок соответствует ранее заданному).\
На вход подаются 5 элементов:
- **robotcl.JoySpeed[0]** - скорость x;
- **robotcl.JoySpeed[1]** - скорость y;
- **turnOsSys = 45** - угол поворота системы координат;
- **ModeOfAngles = 1** - режим вращения;
- **FuncOfAngel = [0, -robotcl.JoyAngle]** - функции вращения.

Строка **103**:
```
JoyArr = robotcl.abcd.set_speed(robotcl.JoySpeed[0], robotcl.JoySpeed[1], turnOsSys = 45, ModeOfAngles = 1, FuncOfAngel = [0, -robotcl.JoyAngle])
```

Для эксперимента можно попробовать поменять значения всех подаваемых на вход элементов. Например:
- **robotcl.JoySpeed[]** - аргумент, равный 0 или 1;
- **turnOsSys** - любое значение угла (поддерживает меньше 0 или больше 360);
- **ModeOfAngles** - значение, равное либо 0, либо 1;
- **FuncOfAngel** - можно менять местами аргументы, умножать на любое число, менять знак, возводить в степень и т.п.


Изменение условия сравнения (**0.05** на любое число, отличное от нуля и до единицы). Данное условие - граница значений джойстика для мгновенной остановки робота. При достижении стиком джойстика заданной границы робот мгновенно останавливается.\
Строка **104**:
```
if ((abs(JoyArr[0])<0.05) and (abs(JoyArr[1])<0.05) and (abs(JoyArr[2])<0.05) and (abs(JoyArr[3])<0.05)):
```


Переменная **data.angle** представляет из себя число, влияющее на функцию, чья производная является значением скорости поворота. Эту переменную можно заменить на **data.x** или **data.y**. Тогда, за управление поворотом будет отвечать правый стик (который по-умолчанию управляет скоростью движения).\
Строка **123**:
```
def callback_mode(data):
        robotcl.mode = data.mode
        robotcl.JoySpeed = [data.x, data.y]
        robotcl.JoyAngle = data.angle
```
